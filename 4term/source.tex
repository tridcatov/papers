\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{setspace}
\usepackage{listings}

\sloppy

\title{Развитие метода компилированной оценки WCET}
\author{Зотов Иван, 422 группа}
\date{\today}

\renewcommand{\contentsname}{Содержание}
\renewcommand{\topmargin}{1pt}
\renewcommand{\textheight}{650pt}

\begin{document}
\pagestyle{plain}


\begin{titlepage}
\begin{center}

{\bf МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\
  Факультет Вычислительной Математики и Кибернетики\\
  Лаборатория Вычислительных Комплексов\\[8mm]
 \includegraphics{resource/gzlogo.png}\\[8mm]
  Курсовая работа\\[24mm]
  Развитие метода компилированной оценки WCET \\
}
\vspace{10mm}
\begin{singlespace}
\begin{tabbing}
	\` Зотов Иван\\
	\` группа 422\\
	\` Научные руководители\\
	\` Гамаюнов Д.\,Ю., Прус В.\,В.
\end{tabbing}
\end{singlespace}
\vspace{5cm}
Москва, 2011
\end{center}
\end{titlepage}

\newpage
\begin{abstract}

В работе рассматриваются метод построения метапрограммы, оценивающей время наихудшего исполнения исходной программы, его принципиальная схема и обоснование корректности. Предложена практическая реализация приведенной схемы.

\end{abstract}
 
\newpage
\tableofcontents

\newpage

\section{Введение}

Оценки времени наихудшего исполнения (WCET) используются в вычислительных системах жесткого и мягкого реального времени. Они являются жизненно необходимыми для программ, время выполнения которых должно быть гарантировано, в частности для программ автономного управления беспилотными летальными аппаратами или искусственными спутниками Земли.

Все программные средства, реализующие функциональность анализатора WCET, являются специализированными коммерческими разработками и анализ их исходных кодов недоступен. Однако известен ряд базовых методов, комбинации которых используются во всех существующих системах оценки  \cite{comsurvey}.

\section{Постановка задачи}

\subsection{Расшифровка темы}
Метод компилированной оценки был предложен Владимиром Прусом\cite{prus}. Необходимость развития метода заключается в следующих подзадачах:
\begin{itemize}
    \item Отладка и оптимизация существующего преобразования программы в исполнимую модель
    \item Разработка и использование механизма аннотаций или внешних подсказок для количества итераций циклов и глубины рекурсии
    \item Разработка механизма интеграции с процессоро-зависимым средством оценки времени
\end{itemize}


\subsection{Актуальность}
Реализация метода построена на базе платформы LLVM. Актуальной на данный момент является задача портирования исходных преобразований метода на новую версию платформы LLVM (разработчиками не поддерживается совместимость API платформы между версиями), а также доведение метода до практической работоспособности на реальных примерах программ. 

\subsection{Цель работы}
Портировать исходные преобразования модели на новую версию платформы LLVM, развить метод в указанных направлениях вплоть до получения средства оценки WCET, работающее на реалистичных примерах.

\subsection{Постановка задачи}
В рамках работы должны быть решены следующие подзадачи:

\begin{itemize}
\item Опрелен набор тестов для проверки корректности преобразований
\item Портирование существующей реализации на новую версию платформы LLVM ($2.4 \to 2.8$)
\item Отладка на подмножестве тестов
\item Оценка возможностей упрощения или оптимизации преобразования
\item Оценка возможности повышения скорости исполнения модeли
\item Определить и реализовать механизмы аннотаций
\item Разработать интеграцию со средством оценки времени для конкретного процессора
\end{itemize}

\newpage

\section{Введение в инструментальную область}

\subsection{LLVM}
LLVM (Low-level Virtual Machine) --- набор компиляторов и низкоуровневых библиотек, являющийся развитием исследовательского проекта университета Иллинойса \cite{llvm}. LLVM предоставляет низкоуровневую абстракцию над аппаратным обеспечением, собственный язык ассемблера и трансляторы в машиные коды многих существующих архитектур.

\subsection{Примитивы LLVM}
Со стороны программиста LLVM поддерживает многоуровневую абстракцию над исходными кодами и исполнимыми байткодами (машинными кодами). В частности, для рассмотрения в данной работе необходимы следующие элементы абстракции:
\begin{itemize}
\item \textbf{Instruction} \textit{(Команда)} --- элементарная инструкция процессору (виртуальному интерпретатору)
\item \textbf{Basic Block} \textit{(Линейный участок)} --- множество последовательных команд без явной передачи управления
\item \textbf{Function} \textit{(Функция)} --- именованное множество линейных участков, связанных потоком управления
\item \textbf{Module} \textit{(Модуль)} --- именнованное множество функций, связанных общим контекстом типов
\item \textbf{Interval} \textit{(Интервал)} --- множество линейных участков, в котором выделен начальный участок, для которого справедливо свойство: \textit{Непосредственные предки всех линейных участков (кроме выделенного, называемого \textbf{головой}) в интервале также принадлежат интервалу}.
\item \textbf{Interval Partition} \textit{(Интервальное подразделение)} --- множество интервалов, составляющих полное покрытие некоторой функции
\end{itemize}

\subsection{Программные инструменты платформы LLVM}

\subsubsection{llvm-gcc}

\textbf{llvm-gcc} --- универсальный компилятор исходных кодов различных языков (по умолчанию C/C++/Ada, возможны разработки фронтэндов для других языков) в байткод LLVM или в машинный код целевой платформы. Поддерживает машинно-независимые независимые оптимизации (уровень -О2 компилятора gcc), а также машинно-зависимые оптимизации для целевых платформ (уровень -О3). Важной особенностью является возможность трансляции в исходные коды LLVM без промежуточного представления в байткоде, что позволяет наглядно оценивать уровень оптимизаций при последующих преобразованиях программы.

\subsubsection{llvm-opt}

\textbf{opt} --- многопоточный оптимизатор программ в байткоде LLVM. Opt создает среду выполнения т.н. модульных оптимизаторов, каждый из которых решает задачу преобразования исходной программы на определенном уровне абстракции. Рассмотренное в данной курсовой работе решение реализовано в виде линейной последовательности преобразований, выполняемых конвейером с помощью оптимизатора.

\newpage
\section{Обзор существующих методов оценки WCET}

\subsection{Статические методы}
Статические оценки времени наихудшего исполнения опираются на несколько базовых методов анализа. Характерной чертой статического анализа является работа над комбинацией исполняемого кода и абстрактной модели вычислительной системы, не включающая исполнение на реальном аппаратном обеспечении или его симуляторе.

\subsubsection{Анализ значений}
Метод позволяет вычислять часть исполняемых адресов для определения точного места обращения к данным (в память или кэш). Полученная информация критична для оценки в условиях жесктого реального времени из-за значительного разрыва в скоростях работы основной памяти и кэшей различного уровня. Расчет выполняется статически за счет отслеживания значений адресных регистров процессора и локальных переменных в каждой точке программы. При некоторой модификации метод может быть эффективно использован для определения ограничений циклов и невыполнимых путей.

\subsubsection{Анализ потока управления}
Метод используется для определения возможных путей исполнения программы и нахождения среди них наихудшего по времени. Получение верхней оценки возможно, поскольку множество путей выполнения программы всегда конечно. Во избежание рассчета оценки для каждого из путей производится выделение некоторого их надмножества, WCET которого является хорошим приближением.

Вход анализа составляет некоторое представление исполняемой программы, например комбинация графа вызовов и графа потока управления, и, возможно, дополнительная информация в виде ограничений на входные данные и итерации циклов. На выходе получаются ограничения на исполнение программы в виде информации о возможности вызовов тех или иных функций, взаимосвязи между условными выражениями, достижимости или недостижимости определенных путей и т.д.

Анализаторы различаются в зависимости от того, в каком виде на вход поступает программа. При прочих равных анализ значительно проще на исходном коде, чем на машинном представлении, но возникают сложности с отображением полученных результатов на скомпилированную программу, поскольку в результате действий оптимизаторов компилятора поток управления может сильно измениться.

\subsubsection{Анализ поведения процессора}
Современные процессоры обладают рядом характеристик, которые делают оценку времени наихудшего исполнения контекстно зависимой относительно данного процессора. В их число входят предсказания ветвлений \cite{branch}, кэши \cite{abs,cache}, конвейеры \cite{anom}. Для получения точных оценок WCET требуется рассмотрение всех этих компонент и их влияние на ход исполнения программы. Это достигается за счет использования моделей процессора различной сложности.

Непосредственная временная оценка не может считаться точной, если построена без учета временных аномалий, возникающих в процессоре под воздействием различных оптимизационных технологий. Однако построение модели процессора является трудоемкой задачей, причем с усложнением модели процессора пропорционально увеличивается сложность самого процесса анализа, теряется его модульность в связи с появлением большого числа учитываемых элементов модели и их нетривиальных взаимосвязей.

Использование модели процессора позволяет моделировать контекст каждой инструкции в программе. Тем самым устраняется избыточность контекстно-независимой оценки. 
Анализ поведения процессора позволяет получать наиболее точные оценки в силу сильного приближения к реальному исполнению программы.

\subsection{Динамические методы}
В основе всех динамических методов лежит исполнение программы на некотором множестве наборов входных данных и измерение времени, затрачиваемое на каждый из наборов. Полученная оценка является состоятельной только при условии, что множество входных наборов полностью покрывает все возможные варианты реальных данных, в противном случае время наихудшего исполнения может оказаться недооцененным. Динамические методы не могут применяться в системах мягкого или жесткого реального времени, поскольку вычисляют среднее время выполнения, а не наихудшее.

\subsection{Метод компилированной оценки WCET}
Метод компилированной оценки (далее КО) разработан Владимиром Прусом в работе \cite{prus} для выполнения оценки WCET программ путем их модификации. Он позволяет получать метапрограмму, вырабатывающий оценку WCET исходной программы с учетом ограничений, наложенных на её входные данные. Метод не является полностью статическим, поскольку требует выполнения результирующей программы на вычислителе. Является модифицированной имплементацией анализа значений. Более подробно метод будет рассмотрен ниже.

\newpage
\section{Решение задачи}

\subsection{Принципиальная схема работы решения}

Для построения метапрограммы, вычислияющей оценку времени наихудшего исполнения целевой программы, к ней применяется ряд преобразований в линейно последовательности. Список преобразований:
\begin{itemize}
    \item Инкрементальная нумерация линейных участков программы
    \item Расстановка конструкторов атомарных оценок
    \item Преобразование линеаризации
    \item Разметка абстрактной семантики программы
    \item Разметка ограничителей глубины рекурсивных вызовов
    \item Означивание переменных, недостижимых в смысле абстрактной семантики
    \item Удаление мертвого кода
\end{itemize}

Проведем более подробное рассмотрение каждого из преобразований конвейера.

\subsection{Преобразования исходной программы}

\subsubsection{Инкрементальная нумерация линейных участков программы}

В процессе работы данного преобразования каждый из линейных участков исходной программы получает уникальный номер. Нумерация ведется последовательно в недетерминированном порядке относительно функций внутри модуля и частично упорядоченно в пределах каждой функции. Таким образом, каждый линейный участок исходной программы обладает номером, заведомо не превышающим любой из номеров его потомков. 

Данная разметка используется для контроля целостности результирующей программы, поскольку в ходе любых преобразований свойство частичной упорядоченности линейных участков относительно их порядковых номеров не должно нарушаться.

\subsubsection{Расстановка конструкторов атомарных оценок}

Каждой инструкции исходной программы сопоставляется некоторая оценка времени её выполнения. В простейшем случае конструктор атомарной оценки представляет собой инкремент соответствующего локального (для линейного участка) счетчика WCET. В более сложном случае ему может быть сопоставлен вызов в соответствующее средство эмуляции процессора. 

Расстановка производится до любых изменений программы, изменяющих поток управления, поскольку на оценку исходной программы не должны влиять служебные конструкции, предназначенные для слияния значений абстрактной интерпретации.

\subsubsection{Преобразование линеаризации}

В данном преобразовании выполняется попытка привести программу к линейному виду. Это достигается за счет анализа серии интервальных подразделений. Основное интервальное подразделение --- весь код определенной функии, поскольку он, очевидно, подпадает под определение интервала. Начинается итеративный процесс разбиения подразделения на более мелкие, причем на каждом этапе процесса производится преобразование получившегося множества интервалов таким образом, чтобы оно представляло собой линейную структуру. Итеративный процесс завершается, когда построено дегенеративное подразделение, т.е. его дальнейшее разбиение приводит к этому же подразделению.

Для каждого интервала в подразделении строится блок слияния (\textit{gate-block}) --- линейный участок, который производит слияние значений, полученных на всех возможных выходах интервала, причем производится слияние как значений переменных программы, так и значение соотвествующих оценок времени исполнения. Т.о. программа на каждой итерации преобразования представляет собой множество интервалов, соединенных между собой блоками слияния.

Если в процессе преобразования встречается явный цикл (передача управления предку данного блока), производится попытка линеаризовать тело цикла, что достигается построением отдельного интервала на основе тела цикла и выделения для него собственного интервального подразделения.

Блок слияния для конструкции ветвления строится на основе переменных, которые изменяются в обоих частях ветвления.

В результате работы преобразования линеаризации получается программа, поток управления которой отличается от исходной программы. Это достигается за счет слияния различных ветвей исполнения в блоках слияния и собственно за счет добавления самих блоков слияния. Корректность преобразования определяется сохранением свойства частичной упорядоченности линейных участков относительно уникальных номеров, полученных на этапе предварительной разметки.

\subsubsection{Разметка абстрактной семантики программы}

Суть преобразования заключается в замене целочисленных (в том числе логических) типов на структуры из пар значений соответствующих типов, характеризующие диапазон изменения переменной данного типа.

В процессе преобразования модификации подвергаются инструкции, оперирующие целочисленными типами, как то:
\begin{itemize}
    \item Арифметические операции
    \item Логические операции
    \item Аллоцирующие операции (\textit{PHI-инструкции})
\end{itemize}

Также изменениям подвергаются прототипы и вызовы функций, принимающие на вход параметры целочисленных типов.

В результате преобразования линеаризованная программа получает возможность оперировать диапазонами значений, что в дальнейшем позволит производить отсечение мертвого кода на этапе выполнения.

\subsubsection{Разметка ограничителей глубины рекурсивных вызовов}

Для ограничений глубины слабо детерминированной рекурсии используется механизм внешней аннотации. В каждой функции производится поиск вызовов других функций. Сохраняя общность рассуждений, положим, что все функции принадлежат одному модулю. Любая функция однозначно идентифицируется в модуле по своему имени. Каждому вызову функции сопоставляется новая глобальная переменная модуля, причем сопоставление ведется по именам вызывающей и вызываемой функций. Каждый вызов функции выделяется в обособленный линейный участок, перед вызовом функций производится декремент сопоставленной глобальной переменной, после вызова --- её инкремент. Вызов функции производится только в том случае, когда соответствующая глобальная переменная отлична от нуля.

После того, как множество переменных определено, у оператора запрашивается значение глобальной переменной для каждого из вызовов функций. Таким образом получаем ограничение на глубину рекурсивных вызовов для любого контура в графе вызовов исходного модуля. Рассмотренный механизм предоставляет также возможность аннотировать циклы с неявным итератором, если вместо контуров графа вызовов использовать контуры потока управления целевой функции.

Таким образом получена программа, любой контур в потоке вызовов которой снабжен явным итеративным ограничителем.

\subsubsection{Разметка значений переменных, недостижимых с точки зрения абстрактной семантики}

В основном данное преобразование направлено на устранение артефактов разметки абстрактной семантики, которые могут появиться при межмодульном взаимодействии, например в случае использования экспортируемых переменных. Преобразование позволяет означить эти переменные, не прибегая к симуляции других модулей, некоторым диапазаном значений, устраняя недетерменизм подобных переменных в получаемой модели.

Также преобразование способно обнаруживать использование неинициализированных переменных в потоке данных и запрашивать их априорный диапазон у оператора.

\subsubsection{Удаление мертвого кода}

Данное преобразование устраняет недостижимый код с учетом ограничений, полученных на предыдущем этапе.
\newpage

\section{Особенности реализации}

\subsection{Исполняемая модель}

В результате выполнения рассмотренного конвейера преобразований из исходной программы получается метапрограмма, принимающая на вход диапазон соотвествующих входных значений исходной программы, выполняющая абстрактную интерпретацию этих диапазонов для основных арифметических и логических операций, выдающая на выходе диапазон выходного значения исходной программы. В качестве побочного эффекта вычисляется значение времени наихудшего исполнения исходной программы.

В исполняемой модели удвоено количество арифметических и логических операций в связи с выполнением операций в абстрактной семантике. Также накладные расходы возрастают при расчете времени наихудшего исполнения для каждой инструкции в участке. Чистым накладным расходом являются блоки слияния.

По требованию корректности, исполняемая модел не допускает оптимизаций любого уровня, поскольку это может привести к изменению потока управления, что автоматически инвалидирует псевдолинейную структуру модели (интервалы, связанные блоками слияний). Таким образом, модель должна быть оттранслирована в машинные коды с явным указанием о запрете оптимизаций, либо же интерпретирована из байткода непосредственно. Очевидно, что максимальный уровень оптимизаций должен быть применен к исходной программе.

\subsection{Тестовое покрытие}

Набор тестов для реализации призван покрыть множество элементарных преобразований, которые предусматриваются при построении исполняемой модели. Тесты разделены по категориям, соотвествтующим таким преобразованиям.

\begin{itemize}
    \item Преобразования линейных участков
    \begin{itemize}
        \item Арифметические операции с одной переменной
        \item Арифметические операции со многоими переменными
        \item Арифметические операции с возвратом значения
    \end{itemize}
    \item Преобразование ветвлений
    \begin{itemize}
        \item Простое ветвление (if-else)
        \item Множественно ветвление (if-elseif-else)
        \item Вложенные ветвления (if-if)
    \end{itemize}
    \item Преобразования циклов
    \begin{itemize}
        \item Простой цикл с явным итератором
        \item Вложенные циклы с явными итераторами
        \item Простой цикл с неявным итератором
    \end{itemize}
    \item Преобразования, связанные с ограничением рекурсии
    \begin{itemize}
        \item Простой взаимно рекурсивный вызов (замкнутый контур из двух узлов)
        \item Сложный рекурсивный вызов (полносвязный контур на трех узлах)
    \end{itemize}
\end{itemize}

\subsection{Адекватность оценки}

Построенная реализация нечувствительна к работе таких элементов современных процессоров, как кэши и конвейеры. Это связано с особенностями построения исполнимой модели.

В частности, возможное кэширование данных в исходной программе инвалидируется значительным объемом служебной информации, которую несет исполняемая модель. Данная информация привносится на этапах линеаризации и разметки абстрактной семантики. Кэши исходной программы и исполнимой модели не могут иметь однозначного соответствия.

С другой стороны, из-за сильного изменения в структуре потока управления на этапе линеаризации, конвейерная обработка данных в исполняемой модели не будут соответствовать соответствующим потокам конвейера в программе исходной.

Считая адекватной оценку, при которой на множестве анализируемых программ можно ввести отношение порядка по времени их наихудшего исполнения, не следует учитывать временные феномены, порождаемые конвейерами и кэшами процессора. В этом случае важно получить только информацию о времени выполнения на процессоре одной инструкции в полном цикле (чтение команды, чтение данных, рассчет, возврат результата).
\newpage
\section{Заключение}

Полученное средство позволяет производить оценку времени на программах с явно итерируемыми циклами, неявно итерируемыми циклами при наличии априорных оценок о числе их итераций, произвольным контуром рекурсивных вызов при наличии априорных оценок о длине значимого пути в контуре, произвольными ветвлениями потока управления.

В ходе работы средства строится исполняемая модель исходной программы, исполнение которой вызывает эквивалентные действия над диапазонами значений входных и внутренних переменных программы. Время работы исполняемой модели линейно зависит от времени выполнения исходной программы в худшем случае.

\newpage
\begin{thebibliography}{99}
\bibitem{comsurvey}Проблема оценки времени наихудшего исполнения (Worst-Case Execution Time Problem - Overview by Willhelm Rheinhard and oth.)
\bibitem{gamajun}AURA: среда высокоскоростного анализа сетевого трафика для задач информационной безопасности (Гамаюнов Д.\,Ю и др.)
\bibitem{prus}Компилированная оценка WCET (Прус В.\,В.)
\bibitem{llvm}Официальная документация LLVM (http://llvm.org)
\bibitem{pass}Создание анализаторов в среде LLVM (Creation of an llvm pass, Lattner, C. and Laskey, J.)
\bibitem{branch}Анализ WCET для процессоров с предсказанием ветвлений (WCET Analysis for Processors with Branch Prediction, Colin, A. and Bernadt, G.)
\bibitem{abs}Предсказание поведения кэша на основе абстркатной интерпретации (Cache Behavior Prediction by Abstract Interpretation, Ferdinand, C. and Martin, F.)
\bibitem{cache}Быстрое и эффективное предсказание поведения кэша для систем реального времени (Fast and Efficient Cache Behavior Prediction for Real-Time Systemsб Ferdinand, C. and Wilhelm, R.)
\bibitem{anom}Временные аномалии в микропроцессорах с динамическим расписанием (Timing Anomalies in Dynamically Scheduled Microprocessors, Lundqvist, T. and Stenstrom, P.)
\bibitem{graph}Анализ графа потока управления для систем реального времени(Control Flow Graphs For Real-Time Systems Analysis, Theiling, H.)
\bibitem{times}Определение ограничений на число исполнений (Determining Bounds on Execution Times, Wilhelm, R.)

\end{thebibliography}

\end{document}
