\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{setspace}
\usepackage{listings}

\sloppy

\title{Развитие метода компилированной оценки WCET}
\author{Зотов Иван, 422 группа}
\date{\today}

\renewcommand{\contentsname}{Содержание}
\renewcommand{\topmargin}{1pt}
\renewcommand{\textheight}{650pt}

\begin{document}
\pagestyle{plain}


\begin{titlepage}
\begin{center}

{\bf МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\
  Факультет Вычислительной Математики и Кибернетики\\
  Лаборатория Вычислительных Комплексов\\[8mm]
 \includegraphics{resource/gzlogo.png}\\[8mm]
  Курсовая работа\\[24mm]
  Развитие метода компилированной оценки WCET \\
}
\vspace{10mm}
\begin{singlespace}
\begin{tabbing}
	\` Зотов Иван\\
	\` группа 422\\
	\` Научные руководители\\
	\` Гамаюнов Д.\,Ю., Прус В.\,В.
\end{tabbing}
\end{singlespace}
\vspace{5cm}
Москва, 2011
\end{center}
\end{titlepage}

\newpage
\begin{abstract}

В работе рассматриваются метод построения метапрограммы, оценивающей время наихудшего исполнения исходной программы, его принципиальная схема и обоснование корректности. Предложена практическая реализация приведенной схемы.

\end{abstract}
 
\newpage
\tableofcontents

\newpage

\section{Введение}

Оценки времени наихудшего исполнения (WCET) используются в вычислительных системах жесткого и мягкого реального времени. Они являются жизненно необходимыми для программ, время выполнения которых должно быть гарантировано, в частности для программ автономного управления беспилотными летальными аппаратами или искусственными спутниками Земли.

С точки зрения информационной безопасности использование реального времени необходимо для своевременного обнаружения угроз, успешного отражения атак и минимизации их воздействия. В области анализа сетевого трафика проблема реального времени становится более явной, поскольку, согласно закону Гилдера, пропускная способность каналов связей растет быстрее, нежели вычислительные мощности узлов. В связи с этим требуются механизмы, позволяющие гарантировать реальное время на узлах при обработке трафика и оптимизировать работу следящих систем. Одним из таких механизмов являются оценки WCET.

Все программные средства, реализующие функциональность анализатора WCET, являются специализированными коммерческими разработками и анализ их исходных кодов недоступен. Однако известен ряд базовых методов, комбинации которых используются во всех существующих системах оценки  \cite{comsurvey}.

\section{Постановка задачи}

\subsection{Расшифровка темы}
Метод компилированной оценки был предложен Владимиром Прусом\cite{prus}. Необходимость развития метода заключается в следующих подзадачах:
\begin{itemize}
    \item Отладака и оптимизация существующего преобразования программы в исполнимую модель
    \item Разработка и использование механизма аннотаций или внешних подсказок для количества итераций циклов и глубины рекурсии
    \item Разработка механизма интеграции с процессоро-зависимым средством оценки времени
\end{itemize}


\subsection{Актуальность}
Реализация метода построена на базе платформы LLVM. Актуальной на данный момент является задача портирования исходных преобразований метода на новую версию платформы LLVM (разработчиками не поддерживается совместимость API платформы между версиями), а также доведение метода до практической работоспособности на реальных примерах программ. 

\subsection{Цель работы}
Портировать исходные преобразования модели на новую версию платформы LLVM, развить метод в указанных направлениях вплоть до получения средства оценки WCET, работающее на реалистичных примерах.

\subsection{Постановка задачи}
В рамках работы должны быть решены следующие подзадачи:

\begin{itemize}
\item Опрелен набор тестов для проверки корректности преобразований
\item Портирование существующей реализации на новую версию платформы LLVM ($2.4 \to 2.8$)
\item Отладка на подмножестве тестов
\item Оценка возможностей упрощения или оптимизации преобразования
\item Оценка возможности повышения скорости исполнения модeли
\item Определить и реализовать механизмы аннотаций
\item Разработать интеграцию со средством оценки времени для конкретного процессора
\end{itemize}

\newpage

\section{Введение в инструментальную область}

\subsection{Среда высокоскоростного анализа трафика AURA}
Среда является разработкой лаборатории вычислительных комплексов и представляет собой комплексное средство сбора и анализа трафика, способное также отслеживать отклонения в поведении исполняемых программ \cite{gamajun}.

\subsubsection{Принципы работы}
Основной функицональной единицей среды является сенсор --- вычислительный узел, в состав которого входит система прогона, ответственная за генерацию потока событий на основе трафика через узел, и набор сценариев, описывающих алгоритмы поведения объектов в сети и на конечных устройствах в терминах конечных автоматов.

\subsubsection{Язык AURA}
В состав среды AURA входит собственный язык для описания конечных автоматов. Единицей языка служит сценарий, описывающий множество состояний и переходов с их предикатами. Состояния определяют внутренний контекст сценария. Переходы могут снабжаться некоторым дополнительным кодом, выполняющим сопроводительные действия в процессе перехода в новое состояние. Предикаты вычисляют логические условия переходов в соответствии с входными событиями.

\subsubsection{Элементы AURA, критичные для оценки WCET}
Критичными для оценки WCET в языке AURA являются конструкции, на выполнение которых сенсор затрачивает наибольшее время. Такими конструкциями являются:
\begin{itemize}
\item Предикаты переходов. Выполняются при обработке очереди событий. 
\item Тела предикатов. Выполняются при завершении выполнения истинности соответствующего предиката, формируют одну или несколько очередей выполнения.
\item Тела состояний. Выполняются при порождении нового экземпляра автомата.
\end{itemize}

\subsection{LLVM}
LLVM (Low-level Virtual Machine) --- набор компиляторов и низкоуровневых библиотек, являющийся развитием исследовательского проекта университета Иллинойса \cite{llvm}. LLVM предоставляет низкоуровневую абстракцию над аппаратным обеспечением, собственный язык ассемблера и трансляторы в машиные коды многих существующих архитектур.

\subsubsection{Универсальный байткод LLVM}
При использовании LLVM программы комплируются в универсальный байткод, который затем может быть транслирован в машинный код существующей архитектуры или непосредственно интерпретируются с помощью пакета виртуальных машин, входящих в систему. В функциональном отношении идентичен байткоду Java или .NET.

\subsubsection{Представление сценариев на языке AURA в LLVM}
В силу возможной разнородности аппаратной базы сенсоров в составе СОА сценарии на языке AURA транслируются в байткод LLVM. Это позволяет избегать избыточности хранения бинарных файлов каждой конкретной платформы сенсоров в репозиториях сценариев. При обработке событий сенсоры используют виртуальные машины LLVM и интерпретируют байткод сценария на лету.

\newpage
\section{Обзор существующих методов оценки WCET}

\subsection{Статические методы}
Статические оценки времени наихудшего исполнения опираются на несколько базовых методов анализа. Характерной чертой статического анализа является работа над комбинацией исполняемого кода и абстрактной модели вычислительной системы, не включающая исполнение на реальном аппаратном обеспечении или его симуляторе.

\subsubsection{Анализ значений}
Метод позволяет вычислять часть исполняемых адресов для определения точного места обращения к данным (в память или кэш). Полученная информация критична для оценки в условиях жесктого реального времени из-за значительного разрыва в скоростях работы основной памяти и кэшей различного уровня. Расчет выполняется статически за счет отслеживания значений адресных регистров процессора и локальных переменных в каждой точке программы. При некоторой модификации метод может быть эффективно использован для определения ограничений циклов и невыполнимых путей.

\subsubsection{Анализ потока управления}
Метод используется для определения возможных путей исполнения программы и нахождения среди них наихудшего по времени. Получение верхней оценки возможно, поскольку множество путей выполнения программы всегда конечно. Во избежание рассчета оценки для каждого из путей производится выделение некоторого их надмножества, WCET которого является хорошим приближением.

Вход анализа составляет некоторое представление исполняемой программы, например комбинация графа вызовов и графа потока управления, и, возможно, дополнительная информация в виде ограничений на входные данные и итерации циклов. На выходе получаются ограничения на исполнение программы в виде информации о возможности вызовов тех или иных функций, взаимосвязи между условными выражениями, достижимости или недостижимости определенных путей и т.д.

Анализаторы различаются в зависимости от того, в каком виде на вход поступает программа. При прочих равных анализ значительно проще на исходном коде, чем на машинном представлении, но возникают сложности с отображением полученных результатов на скомпилированную программу, поскольку в результате действий оптимизаторов компилятора поток управления может сильно измениться.

\subsubsection{Анализ поведения процессора}
Современные процессоры обладают рядом характеристик, которые делают оценку времени наихудшего исполнения контекстно зависимой относительно данного процессора. В их число входят предсказания ветвлений \cite{branch}, кэши \cite{abs,cache}, конвейеры \cite{anom}. Для получения точных оценок WCET требуется рассмотрение всех этих компонент и их влияние на ход исполнения программы. Это достигается за счет использования моделей процессора различной сложности.

Непосредственная временная оценка не может считаться точной, если построена без учета временных аномалий, возникающих в процессоре под воздействием различных оптимизационных технологий. Однако построение модели процессора является трудоемкой задачей, причем с усложнением модели процессора пропорционально увеличивается сложность самого процесса анализа, теряется его модульность в связи с появлением большого числа учитываемых элементов модели и их нетривиальных взаимосвязей.

Использование модели процессора позволяет моделировать контекст каждой инструкции в программе. Тем самым устраняется избыточность контекстно-независимой оценки. 
Анализ поведения процессора позволяет получать наиболее точные оценки в силу сильного приближения к реальному исполнению программы.

\subsection{Динамические методы}
В основе всех динамических методов лежит исполнение программы на некотором множестве наборов входных данных и измерение времени, затрачиваемое на каждый из наборов. Полученная оценка является состоятельной только при условии, что множество входных наборов полностью покрывает все возможные варианты реальных данных, в противном случае время наихудшего исполнения может оказаться недооцененным. Динамические методы не могут применяться в системах мягкого или жесткого реального времени, поскольку вычисляют среднее время выполнения, а не наихудшее.

\subsection{Метод компилированной оценки WCET}
Метод компилированной оценки (далее КО) разработан Владимиром Прусом в работе \cite{prus} для выполнения оценки WCET программ путем их модификации. Для программы с ацикличным графом управления достаточны следующие изменения:

\begin{itemize}
\item Каждой переменной программы ставится в соответствие пара переменных, отражающая диапазон значений исходной:

$V\to \{V_{min}\,V_{max}\}$

\item Точки ветвления программы вида

{\slshape if ( condition ) then statement1 else statement2} преобразуются к

{\slshape if~(~condition~)~then~statement1 if~(~countercondition~)~then~statement2}.

\item Каждому блоку в программе ставится в соответствие переменная W, характеризующая WCET данного блока. W увеличивается согласно некоторой метрике (например, время выполнения конкретной инструкции).

\item WCET объемлющего блока связывается с WCET вложенных блоков, полученных из развертки ветвлений, некоторой функцией, как правило максимум из соответствующих оценок.

\item Модифицированная программа исполняется, причем входными значениями являются диапазоны значений входных переменных исходной. В результате работы программа генерирует собстсвенную оценку WCET, причем не учитывает недостижимые по данным пути (в частности ветка {\slshape if ($x< 0$) then wcet\_statement} не будет выполнена при диапазоне значений $x:[1,5]$).

\end{itemize}

Таким образом метод КО позволяет путем специфичной компиляции программы получать её эквивалент, вырабатывающий оценку WCET исходной программы с учетом ограничений, наложенных на её входные данные. Метод не является полностью статическим, поскольку требует выполнения результирующей программы на вычислителе. Является модифицированной имплементацией анализа значений.

\subsection{Результаты рассмотрения существующих решений оценки WCET}

Рассмотренный набор статических методов представляет принципиальные схемы решений для получения оценки WCET необходимой степени точности. Однако не существует некоммерческих реализаций или реализаций с открытым исходным кодом, решающих данную задачу.

Метод КО в чистом виде непригоден для решения задачи данной работы, поскольку не является статическим и не может быть внедрен в компилятор языка AURA.

Данная работа направлена на создание средства, адаптирующего метод КО и обладающего способностью встраиваться в конвейер компиляции для полностью статической оценки WCET.

\newpage
\section{Решение задачи}

\subsection{Принципиальная схема работы решения}
Предлагается схема анализа на основе графа потока управления с применением техник, используемых при анализе значений. Анализ выполняется над LLVM-представлением сценария после того, как компилятор выполнит все возможные оптимизации и преобразования кода. Сценарии AURA транслируются в байткод LLVM, причем компоненты сценария оформляются как функции объектного кода и однозначно определяются по своим префиксам. \\[6mm]

\begin{tabular}{|l|c|}
\hline
\multicolumn{2}{|c|}{Отображение компонентов сценария} \\
\hline
предикаты переходов & !\_\_idstrans<transition\_name>\_predicate  \\
\hline
тела переходов & !\_idstrans<transition\_name>\_func \\
\hline
тела состояний & sc<scenarion\_name>; !\_idsDataInit \\
\hline
\end{tabular}
\\[6mm]

Таким образом, выполнение анализа над байткодом LLVM полностью определяет WCET для всех компонентов сценария, требующих соответствующей оценки.

Граф потока управления на входе обеспечивается оптимизатором, входящим в состав пакета LLVM. Диапазоны входных значений предоставляются оператором системы.

Рассчет WCET выполняется в метрике инструкций LLVM. В дальнейшем можно перейти к использованию временных метрик, задав соответствие между инструкциями LLVM  и временем их исполнения.

\begin{center}
\begin{picture}(400,100)
%bitecode
\put(55,75){\oval(100,30)}
\put(20,70){{Байткод llvm}}
%bitecodeinput
\put(55,60){\vector(0,-1){20}}
%opt
\put(5,5){\line(1,0){100}}
\put(5,5){\line(0,1){35}}
\put(105,5){\line(0,1){35}}
\put(5,40){\line(1,0){100}}
\put(45,20){opt}
%optoutput
\put(105,20){\vector(1,0){20}}
\put(110,20){\line(0,1){60}}
\put(110,80){\vector(1,0){15}}
%CFG
\put(180,80){\oval(100,30)}
\put(165,75){{CFG}}
%Constant ranges
\put(180,20){\oval(100,30)}
\put(150,15){{Fixed ranges}}
%Dynamic ranges
\put(290,20){\oval(100,30)}
\put(250,15){{Variable ranges}}
%wcet tool and input-output
\put(180,35){\line(0,1){30}}

\put(180,55){\vector(1,0){60}}
\put(290,35){\vector(0,1){15}}

\put(240,50){\line(1,0){100}}
\put(240,50){\line(0,1){40}}
\put(240,90){\line(1,0){100}}
\put(340,50){\line(0,1){40}}

\put(340,70){\vector(1,0){25}}

%WCET
\put(380,50){\oval(30,90)}
\put(375,70){{W}}
\put(375,55){{C}}
\put(375,40){{E}}
\put(375,25){{T}}


\end{picture}
Рис. 1 Поток данных в решении.
\end{center} 

\subsection{Модификация метода компилированной оценки}

Поскольку метод компилированной оценки WCET не является полностью статическим, для него предлагаются следующие модификации:

\begin{itemize}

\item Модификация исходной программы не выполняется. Вместо этого используются принципы абстрактной интерпретации, поскольку байткод LLVM предоставляет исчерпывающую информацию о переменных и их расположении в памяти \cite{pass}. Операции, однозначно определяемые по их коду, выполняются над диапазонами соответствующего операнда. Каждая операция изменяет ровно один операнд, поскольку LLVM реализует стратегию SSA (Static Single Assignment).

\item Развертка ветвлений не выполняется, поскольку абстрактная интерпретация позволяет производить анализ над обоими путями выполнения при обнаружении ветвления.

\end{itemize}

Таким образом исходный метод адаптируется к статическому анализу, поскольку более не требует интерпретации программы на реальном вычислителе. В то же время основная идея --- отслеживание диапазонов значений и удаление недостижимых путей на их основе --- сохраняется.

\newpage
\section{Особенности реализации}

\subsection{Выполнение анализа}

Анализ объектного кода программы выполняется после завершения работы оптимизаторов языка LLVM. При этом в дальнейшем код не претерпевает никаких преобразований относительно своего потока управления, поэтому оценка WCET на его основе не потеряет актуальности.

После того, как оптимизатор построил граф потока управления программы, анализатор начинает строить символьную таблицу программы, включающую в себя имена переменных, адреса объектного кода, ассоциированные с ними, и диапазоны их значений. Для констант и преинициализированных выражений верхняя и нижняя границы диапазона устанавливаются равными соответствующему инициализирующему значения. Для переменных, значение которых определяется на этапе исполнения (в частности, значения полей событий), анализатор запрашивает информацию о диапазонах у пользователя.

После завершения построения символьной таблицы на основе глобальных переменных LLVM (содержатся в преамбуле программы), анализатор начинает последовательный просмотр функций программы. В общем виде анализ функций выглядит следующим образом: 

\begin{enumerate}
\item Анализатор определяет входной линейный участок функции и начинает последовательную интерпретацию его инструкций. Каждая проинтерпретированная инструкция увеличивает значение WCET данного линейного участка.
\item При достижении ветвления на основе таблицы символов определяется достижимость каждой из ветвей.
\item Для каждой достижимой ветви таблица символов копируется и рекурсивно продолжается анализ.
\item При достижении линейного участка, имеющего более одного предка (типичный пример - участок с меткой return) ожидаются таблицы символо от всех путей, ведущих к данному участку, а затем их значения соответствующим образом сливаются: $V_{max}=\max\{V^i_{max}\};V_{min}=\min\{V^i_{min}\}$.
\item После завершения анализа потомков WCET предка является суммой собственной оценки и максимальной из оценок потомков.
\end{enumerate}

Для разрешения конфликтов, связанных с циклами или множественным наследованием линейного участка, потребуются следующие структуры данных:

\begin{itemize}
\item Таблица имен линейных участков, анализ WCET для которых завершен. Поскольку метки линейных участков уникальны в пределах функции, наличие таблицы позволяет разрешить проблему множественного наследования.
\item Таблица имен линейных участков, анализ WCET для которых находится в процессе выполнения. Эта таблица позволяет определить циклы потока управления. Возможно разрешение данного цикла путем указания максимального числа итераций цикла или его определения из контекста.
\item Таблица имен линейных участков, недостижимых при текущих диапазонах входных значений. Устраняет возможность ожидания оценки недостижимых путей. 
\end{itemize}

Рекурсивные вызовы можно отслеживать, поддерживаю также таблицы функций, для которых анализ завершен или продолжается.

\subsection{Модули оптимизатора LLVM}
Предложенная реализация выполнена на основе модуля оптимизатора LLVM. Модуль оформляется как разделяемая библиотека и может быть встроен в цепь компиляции программы. Оптимизатор LLVM на основе анализа объектного кода сценария предоставляет его граф потока управления. Полученная информация используется модулем для построения оценки WCET, поскольку граф потока управления дает исчерпывающую информацию о линейных участках программ и их взаимосвязях.

Модули оптимизатора инкапсулированы в безымянное пространство имен и не могут обмениваться между собой данными. Однако существует возможность модифицировать сущности языка LLVM (функии, линейные участки, инструкции), снабдив их дополнительной информацией о собственном WCET. Таким образом возможно распараллеливание работы нескольких модулей-оценщиков, поскольку оптимизатор LLVM поддерживает многопоточность работы своих модулей и оптимизацию их совместной работы.
	
\subsection{Результаты работы решения}

Решение было протестировано на ацикличных сценариях с отсутствием рекурсивных вызовов. При этом вырабатывается точная оценка WCET компонентов сценариев в метрике количества инструкций максимального пути в графе потока управления. Недостижимые по данным пути и ветвления не анализируются.

Оценка для цикличных программ не выполняется, поскольку абстрактная интерпретация циклов для поддержания адекватности символьной таблицы требует неприемлемого для работы времени. Возможна модификация метода для работы с циклами, однако она потребует поиска метода, позволяющего сохранять приемлемую погрешность для диапазонов значений переменных в цикле, не производя их абстрактную интерпретацию \cite{bound}.

Те же соображения относятся к рекурсивным вызовам функций.

\subsection{Возможности расширения реализации}

В силу модульности реализации и расширяемости структур LLVM существует возможность расширения реализации путем построения новых модулей оптимизатора.

В частности, абстрактную интерпретацию можно выполнять на модели процессора, адавтированной под использование с оптимизатором LLVM. Внедрение подобной модели позволит вместе с анализом потока управления и значений выполнять анализ поведения процессора, вводя уточненную временную метрику WCET и улучшая точность оценки. В зависимости от сложности внедряемой модели возможен также анализ обращений к памяти и учет воздействия на время исполнения кэшей и конвейера вычислителя.

При сохранении данных символьных таблиц для некоторого сценария и их копирования при каждом непоглощающем переходе существует возможность оценки WCET для некоторого дерева экземпляров автомата на определенном потоке событий.

\subsection{Тестовый сценарий}
Следующий код представляет собой листинг тривиального сценария на языке AURA.
{\lstset{language=C++}
\begin{tabbing}
\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\\
\#include "aEvent.h"\\
scenario sampleScenario(aEvent e)\{\\
\>initial state single \{\}\\
\>consuming transition single -$>$ single\\
\>\>event aEvent(false) \{\\
\>\>\>if (e.a > 6) \{\\
\>\>\>\>int i = 0; i++;\\
\>\>\>\} else \{\\
\>\>\>\>int i = 0; int j =0; int k = j + i; k++;\\
\>\>\>\}\
\>\>\}\\
\};\\
\end{tabbing}
}
{\center Рис. 2 Тривиальный сценарий на языке AURA}

Заголовочный файл содержит описание класса тестового события, обладающего единственной публичной переменной $a$, значение которой влияет на ход выполнения тела перехода.

LLVM-псевдокод функции перехода:
{\lstset{language=c}
\begin{tabbing}
\quad\quad\=\\
define void \@"scenario::!\_\_idstrans\_1\_func"($<$Event pointer$>$) nounwind \{\\
entry: [6]\\
\>\%1 = <event variable resolve>\\
\>\%2 = icmp gr i32 \%1, 6 \\
\>br i1 \%2, label \%bb, label \%bb1 \\
bb: [4]\\
\><"True"~ branch calculation>\\
\>br label \%bb2\\
bb1: [8]\\
\><"False"~ branch calculation>\\
\>br label \%bb2\\
bb2: [1]\\
\>br label \%return\\
return: [1]\\
\>ret void\\
\}\\
\end{tabbing}}

Метки вида "name:" являются входными точками соответствующих линейных участков. Числа в квадратных скобках выражают число инструкций в линейном участке. Граф потока управления ромбовидный, сходящийся на участке bb2.

При вычислении WCET с диапазоном входной переменной события $[-10,10]$ оценка окажется равной $6+8+1+1 = 16$. Изменив входной диапазон на $[10,100]$ мы сделаем участок bb1 недостижимым по данным и оценка вычислится как $6+4+1+1 = 12$.


\newpage
\section{Заключение}
Предложенный метод решения задачи позволяет получать оценку WCET для ацикличных сценариев языка AURA с отсутствием рекурсий.

Оценка выполняется в метрике числа выполняемых инструкций, может быть использована при оптимизации обработки очередей переходов и деревьев экземпляров автоматов. В данной работе задача оценки решается с помощью комбинаций анализа графа потока управления и анализа входных значений. Оценка улучшается за счет устранения из рассмотрения недостижимых по данным путей.

Разработанное программное решение использует существующее решение в виде оптимизатора языка LLVM, предоставляющего исчерпывающую информацию о графе потока управления сценария на основе объектного байткода. Решение может быть сравнительно легко расширено для рассчета WCET циклических программ, программ с рекурсивными вызовами и деревьев экземпляров автоматов для данного потока событий.

\newpage
\begin{thebibliography}{99}
\bibitem{comsurvey}Проблема оценки времени наихудшего исполнения (Worst-Case Execution Time Problem - Overview by Willhelm Rheinhard and oth.)
\bibitem{gamajun}AURA: среда высокоскоростного анализа сетевого трафика для задач информационной безопасности (Гамаюнов Д.\,Ю и др.)
\bibitem{prus}Компилированная оценка WCET (Прус В.\,В.)
\bibitem{llvm}Официальная документация LLVM (http://llvm.org)
\bibitem{pass}Создание анализаторов в среде LLVM (Creation of an llvm pass, Lattner, C. and Laskey, J.)
\bibitem{branch}Анализ WCET для процессоров с предсказанием ветвлений (WCET Analysis for Processors with Branch Prediction, Colin, A. and Bernadt, G.)
\bibitem{abs}Предсказание поведения кэша на основе абстркатной интерпретации (Cache Behavior Prediction by Abstract Interpretation, Ferdinand, C. and Martin, F.)
\bibitem{cache}Быстрое и эффективное предсказание поведения кэша для систем реального времени (Fast and Efficient Cache Behavior Prediction for Real-Time Systemsб Ferdinand, C. and Wilhelm, R.)
\bibitem{anom}Временные аномалии в микропроцессорах с динамическим расписанием (Timing Anomalies in Dynamically Scheduled Microprocessors, Lundqvist, T. and Stenstrom, P.)
\bibitem{graph}Анализ графа потока управления для систем реального времени(Control Flow Graphs For Real-Time Systems Analysis, Theiling, H.)
\bibitem{times}Определение ограничений на число исполнений (Determining Bounds on Execution Times, Wilhelm, R.)

\end{thebibliography}

\end{document}
